export const database = [
  {
    title: " 후보키에 대해 설명해주세요.",
    content: `후보키란 데이터를 유일하게 식별하기 위해 사용하는 속성의 집합으로 두가지 특징인 유일성과 최소성을 만족해야합니다.
유일성이란 키 하나로 해당 데이터를 유일하게 식별할 수 있어야하며    
최소성이란 식별에 필요한 최소한의 속성으로만 구성되어야 한다는 특징입니다.
`,
  },
  {
    title: "기본키에 대해 설명해주세요.",
    content: `기본키란 후보키 중에서 선택한 메인 키이며 Null값을 가질 수 없고 Unique하다는 특징이 있습니다.`,
  },
  {
    title: "대체키에 대해 설명해주세요.",
    content: `후보키 중 기본키를 제외한 나머지 키를 의미합니다.`,
  },
  {
    title: "슈퍼키에 대해 설명해주세요",
    content: `후보키중에서 유일성은 만족하지만 최소성을 만족하지 못하는 키를 의미합니다.`,
  },
  {
    title: "외래키에 대해 설명해주세요.",
    content: `다른 테이블의 기본키를 참조하는 속성의 집합을 의미합니다.`,
  },
  {
    title: "JOIN에 대해 설명해주세요.",
    content: `두개이상의 테이블을 연결해서 데이터를 검색하는 쿼리문 이며 Inner join, left outer join, right outer join, full outer join 등이 있습니다.`,
  },
  {
    title: "이상(Anomaly)에 대해 설명해주세요.",
    content: `이상이란 스키마를 잘못 설계해서 데이터의 중복이 일어나 발생하는 문제로

자료를 삽입할때 의도하지 않은 자료까지 필요한 **삽입 이상**,

중복된 데이터중 일부만 수정되는 **갱신 이상**,

어떤 정보 삭제시 다른 정보까지 같이 삭제되어버리는 **삭제 이상**이 있습니다.
`,
  },
  {
    title: "무결성에 대해 설명해주세요.",
    content: `무결성이란 데이터의 중복이나 누락없이 데이터베이스의 구성 규칙들이 유지되는 일관성이 보장된 상태를 의미합니다.`,
  },
  {
    title: "정규화에 대해 설명해주세요.",
    content: `정규화란 테이블간 중복 데이터를 허용하지 않기 위해 데이터를 구조화 하는 작업입니다.
정규화의 목적은 무결성을 지키고 이상 현상을 방지하는 것이며,
1, 2, 3단계와 BCNF 정규형이 있습니다.    
**제 1 정규화**는 하나의 컬럼에는 하나의 데이터만 저장하는 것을 의미합니다.

ex) 도서관 회원 테이블에서 빌린 책 컬럼에는 하나의 책만 저장하고 한 사람이 여러 책을 빌리면 로우를 추가함

**제 2정규화**는 현재 테이블의 주제와 관련없는 컬럼을 다른 테이블로 분리하는 것

전문적인 정의 : Partial dependency(composit primary key에 종속된 컬럼)를 제거한 테이블 ex) 책 가격은 책 이름에 종속되어있음 그럼 책 가격과 책 이름을 따로 분리

단점 : 정보 검색시 여러 테이블을 함께 JOIN 해야함

ex) 도서관 회원 테이블에서 책 가격은 회원 테이블과 관련이 없으므로 책 테이블을 회원 테이블에서 분리함

**제 3정규화**는 기본 키가 아닌 일반 컬럼에 종속된 컬럼을 다른 테이블로 분리하는 것

ex) 책 테이블에서 저자와 저자의 출신 대학 컬럼이 있을 때 저자의 출신 대학은 저자라는 일반 컬럼에만 종속되어 있으므로 저자 테이블로 따로 분리함

단점 : 정보 검색시 여러 테이블을 함께 JOIN 해야함

**BCNF**는 모든 결정자가 후보키가 되도록 테이블을 분리하는 것입니다.

- 결정자 : X 컬럼이 Y컬럼의 값을 결정하는 것

ex) 저자 → 저자 출신 대학


보통 관계형 데이터베이스는 제 3정규화 or BCNF까지 해 놓음`,
  },
  {
    title: "인덱스에 대해 설명해주세요.",
    content: `데이터를 검색시 빠르게 찾으려면 이분 탐색을 해야하므로 검색이 자주 일어나는 특정 컬럼을 복사후 트리 구조로 저장 해놓는 방법을 인덱스라고 합니다.
단점은 인덱스를 위한 용량이 추가되고, 데이터 삽입 삭제 시 오버헤드가 발생합니다.
- Clusterd Index : Primary key는 자동정렬이 되어있으므로 index를 만들 필요 없다.
`,
  },
  {
    title: "인덱스의 자료구조에 대해 설명해주세요.",
    content: `인덱스는 이분 탐색을 위해 트리 자료구조로 저장됩니다.
단 노드에 데이터를 하나만 저장하면 트리의 레벨이 너무 깊어지므로 B 트리의 형태로 저장을 하며 실제 데이터베이스는 B 트리의 개선 버전인 B+ 트리 자료구조를 사용합니다.
`,
  },
  {
    title: "B+tree 알고리즘에 대해 설명해주세요.",
    content: `B+ 트리란 일반적인 트리자료구조와 다르게 데이터를 노드마다 보관하는것이 아닌 리프 노드에만 데이터를 보관합니다.

그리고 나머지 노드에는 탐색시 사용될 가이드만 제공을합니다.

또한 리프 노드들끼리도 서로 연결이 되어있어서 범위 검색이 매우 쉽다는 장점이 있습니다. (Hash Table을 사용하지 않는 이유)`,
  },
  {
    title: "Primary 인덱스와  Secondary 인덱스에 대해 설명해주세요.",
    content: `프라이머리 인덱스는 프라이머리 키에 대한 인덱스로 클러스터드 인덱스가 포함됩니다.

세컨더리 인덱스는 프라이머리키 이외의 다른 컬럼에 대한 인덱스를 의미합니다.`,
  },
  {
    title: "Composite 인덱스에 대해 설명해주세요.",
    content: `복합 인덱스란 두개 이상의 컬럼을 인덱스로 생성하는 것을 의미합니다.

개별적으로 인덱싱 될때보다 두가지 이상의 컬럼을 모두 이용해 효율적인 검색이 가능하다는 장점이 있으나,

인덱스의 크기가 증가해 공간을 많이 차지한다는 단점이 있고, 인덱싱할 컬럼의 순서를 정할때 자주 검색되는 열 순으로 주의해서 지정해야합니다.

ex) 책 이름과 책 저자로 인덱스를 걸었을때 책 저자만 검색하는 경우 인덱싱이 무의미 해짐`,
  },
  {
    title: "인덱스의 성능에 고려해야할 사항에 대해 설명해주세요.",
    content: `인덱스를 무분별하게 걸면 오히려 오버헤드가 발생할 수 있습니다.

예를들어 삽입 삭제가 빈번하게 일어나는 컬럼을 인덱싱할 경우 정렬 상태를 유지하기 위해 인덱스 구조를 변경해야하므로 오히려 성능에 악영향을 미칠 수 있습니다.

카디널리티가 낮은 컬럼은 일반적으로는 인덱싱 하지 않는 것이 좋지만 자주 조회되거나 조건절에 자주 사용되는 경우에는 인덱스를 생성하는 것이 좋을 수도 있어서 뭐든지 상황에 맞춰서 성능 측정을 해보고 최선의 선택을 해야할 것 같습니다.`,
  },
  {
    title: "트랜잭션에 대해 설명해주세요",
    content: `트랜잭션이란 작업 완전성을 보장하는 일종의 논리적 단위입니다.

트랜잭션을 이용해서 일련의 작업을 완벽하게 처리하지 못했을때 원 상태로 복구해서 일부만 적용되는 상황을 방지할 수 있습니다.`,
  },
  {
    title: "트랜잭션의 특성에 대해 설명해주세요.",
    content: `
트랜잭션은 ACID라는 4가지 특성을 만족해야합니다.

원자성은

트랜잭션의 작업은 원자단위로 실행되야하며 일련의 작업이 순차적으로 성공해야 다음 작업을 수행하도록 동작되어야 합니다.

일관성은

트랜잭션이 완료된 이후에도 작업전과 동일하게 일관성을 보장해야한다는 특징입니다.

고립성은

각각의 트랜잭션이 간섭없이 독립적으로 수행되어야 하며

지속성은

트랜잭션이 정상적으로 종료되었다면 영구적으로 작업의 결과가 저장 되어야합니다.`,
  },
  {
    title: "트랜잭션 격리 수준에 대해 설명해주세요.",
    content: `
- **SERIALIZABLE (직렬화 가능)**

특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다. 가장 높은 데이터 정합성을 갖으나, 성능은 가장 떨어진다. 이 격리 수준에서는 단순한 SELECT 쿼리가 실행되더라도, 데이터베이스 락이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없게된다.

- **REPEATABLE READ (반복 가능한 읽기)**

특정 행을 조회시 항상 같은 데이터를 응답하는 것을 보장하는 격리 수준이다. 하지만, SERIALIZABLE과 다르게 행이 추가되는 것을 막지는 않는다. 이로 인해 팬텀 리드 현상이 발생할 수 있다.

MySQL의 InnoDB엔진의 기본 격리 수준이 REPEATABLE READ이다.

- Phantom Read 발생 가능
- **READ COMMITTED (커밋된 읽기)**

**커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용**
하는 격리 수준이다. 즉, 특정 트랜잭션이 이루어지는 동안 다른 트랜잭션은 해당 데이터에 접근할 수 없다. 가장 많이 사용되는 격리 수준이며, 오라클 등 에서 기본값으로 설정되어있다.

- Phantom Read 발생 가능
- Non-Repeatable Read 발생 가능
- **READ UNCOMITTED (커밋되지 않은 읽기)**

커밋이 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용하는 격리 수준이다. 데이터 부정합 문제가 발생할 확률이 높지만, 성능은 가장 빠르다. 데이터를 어림잡아 집계하는 등의 연산에서 사용하면 좋다.

- Dirty Read 발생 가능
- Non-Repeatable Read 발생 가능
- Phantom Read 발생 가능
`,
  },
  {
    title: "트랜잭션 격리 수준에 따라 발생할 수 있는 문제점을 설명해주세요.",
    content: `
### **더티 리드 (Dirty Read)**

더티 리드는 특정 트랜잭션에 이해 **데이터가 변경되었지만, 아직 커밋되지 않은 상황에서 다른 트랜잭션이 해당 변경 사항을 조회할 수 있는 문제**를 말한다.

이 문제는 트랜잭션 A가 데이터를 변경하고 커밋하지 않은 시점에 트랜잭션 B가 변경된 데이터를 읽어온 상황에서, 트랜잭션 A가 변경 내용을 커밋하지 않고 **롤백**한 상황에서 치명적이다. 트랜잭션 B는 무효가 된 값을 읽고 처리하므로 문제가 발생한다.

### **반복 불가능한 조회 (Non-Repeatable Read)**

**같은 트랜잭션 내에서 같은 데이터를 여러번 조회했을 때 읽어온 데이터가 다른 경우를 의미한다.

### **팬텀 리드 (Phantom Read)**

Non-Repeatable Read의 한 종류로 조회해온 결과의 행이 새로 생기거나 없어지는 현상이다.`,
  },
  {
    title: "DB Lock에 대해 설명해주세요.",
    content: `설명없음`,
  },
  {
    title: "트랜잭션 데드락에 대해 설명해주세요.",
    content: `
데이터베이스에서 데드락이란 두 개 이상의 트랜잭션이 서로 원하는 데이터의 Lock 풀리길 기다리는 걸 의미합니다. 이는 시스템 리소스를 잡아먹어 해결을 해주어야 하는데

해결방법으로는 예방 기법과 회피기법이 있습니다.

예방기법의 경우 트랜잭션이 실행되기전 필요한 모든데이터를 락을 걸고 실행하는 것인데 이 경우 트랜잭션의 병행성을 저해하고 starvation이 발생할 수 있습니다.

따라서 보통의 경우 회피 기법을 주로 사용하며 트랜잭션의 시작 순서에 따라 뒤늦게 들어온 트랜잭션이 롤백하여 자원을 양보하는 방식입니다.`,
  },
  {
    title: "저장 프로시저에 대해 설명해주세요.",
    content: `
저장 프로시저는 데이터베이스 내에 저장되는 일련의 SQL문의 집합으로 단순히 저장 프로시저를 호출함으로써 쿼리의 결과를 받아오기 때문에 반복적으로 수행하거나 복잡한 쿼리의 SQL문을 단순화하는데 사용하는 것으로 알고 있습니다.
`,
  },
  {
    title: "Statement와 PrepareStatement에 대해 설명해주세요.",
    content: `
Statement는 SQL 쿼리를 실행하기 위한 인터페이스로 매번 SQL 문을 실행할때마다 새로운 컴파일을 하지만 PreparedStatement는 컴파일된 쿼리를 재사용하고 동적 쿼리와 SQL 인젝션 같은 보안에 더 좋다고 알고 있습니다.
`,
  },
  { title: "소프트 딜리트에 대해 설명해주세요.", content: `설명없음` },
  {
    title: "ORM과 ORM 사용시 장단점을 설명해주세요.",
    content: `
ORM은 객체와 관계형 데이터베이스의 데이터를 매핑하는 것으로

SQL문보다 보다 직관적이고 객체지향적으로 코드를 유지보수할 수 있습니다.

또한, 대부분의 ORM은 DB에 종속적이지 않으므로 애플리케이션에서 데이터베이스에 대한 종속성을 줄여주는 역할도 할 수 있습니다.

다만, 고성능이 필요한 쿼리의 경우 튜닝이나 raw Query를 직접 짜야하는 경우가 생길 수 있습니다.

`,
  },
  {
    title: "RDBMS와 NoSQL에 대해 설명해주세요.",
    content: `
RDBMS는 관계형 데이터 베이스로 정해진 스키마에 따라 데이터가 저장되고 관계를 통해 여러 테이블로 데이터가 분산되어 저장됩니다.

대표적으로는 MySQL, Oracle 같은 서비스가 있습니다.

NoSQL의 경우 RDBMS와 반대로 스키마와 테이블간 관계가 없이 문서단위로 데이터를 저장하며  대표적으로  MongoDB와 같은 서비스가 존재합니다.

RDBMS의 장점은 명확하게 스키마를 정의하므로 데이터의 무결성을 보장하지만 대신 유연성이 떨어지고 NoSQL의 경우 스키마가 없어 유연하지만 데이터가 중복되거나 JOIN문을 사용할 수 없어 컬렉션을 통해 데이터를 처리해야하는 단점이 있습니다.`,
  },
  {
    title: "레디스에 대해 설명해주세요.",
    content: `레디스는 키밸류 기반의 인메모리 데이터베이스입니다.

유사한 데이터베이스로 Memcached가 있는데 Memcached에 비해 레디스는  set, hash, list와 같은 자료구조를 지원하는 특징이 있습니다.

또한 싱글 스레드라는 특징이 있지만 커널레벨의 Multiplexing을 적용하여 동시성을 보장하기때문에 싱글 스레드임에도 고성능 퍼포먼스를 보여주며, 6.0부터는 I/O작업에 위한 멀티 스레드를 도입했습니다.

단, 메모리는 휘발성이기에 사용할 데이터의 특징에 맞게 적용해야합니다.
`,
  },
  { title: "아이솔레이션 레벨에대해 설명해주세요.", content: `설명없음` },
];
